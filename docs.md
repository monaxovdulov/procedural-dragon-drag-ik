# Процедурный дракон (Pygame): Drag IK + "рёбра" + степпинг лапок

Этот репозиторий содержит один файл `main.py` с тех-арт демо: "восточный" дракон как длинная кинематическая цепь фиксированной длины, с несколькими режимами рендера и лапками на 2-bone IK со "sticky" опорами и шагом.

## Запуск

- Установка зависимостей: `uv sync`
- Запуск: `uv run main.py`

## Управление

- `ESC` выход
- `R` reset (пересобрать позу: позвоночник + лапки)
- `D` debug (точки, нормали, опоры лап)
- `1` `mode="bones"` (скелет + рёбра)
- `2` `mode="skin"` (обводка тела лентой)
- `3` `mode="hybrid"` (оба)

## Архитектура `main.py` (что где лежит)

- Helper-функции: `clamp`, `smoothstep01`, `safe_normalize`, `rotate_rad`, `solve_two_bone_ik_2d`.
- `Leg`: состояние одной лапы, "липкая" опора в мире и шаг.
- `Dragon`: параметры, состояние позвоночника (`points`), апдейт и отрисовка.
- `main()`: цикл Pygame, обработка событий, `dragon.update()` и `dragon.draw()`.

## Алгоритмы (суть)

### Голова: пружина на курсор

- Храним `head_vel`.
- Ошибка `to_target = mouse - head`.
- Ускорение `accel = to_target * head_spring`.
- Демпфирование скорости экспонентой по `dt`: `head_vel *= exp(-head_damping * dt)`.
- Ограничение скорости: `head_max_speed` (px/s).

### Позвоночник: Drag IK / Follow-the-Leader

- Храним `N` точек `points[i]` и длину сегмента `L`.
- Сначала обновляем голову (`points[0]`), затем идём от головы к хвосту `i=1..N-1`.
- Для сегмента `i` берём вектор от обновлённого `prev=points[i-1]` к старому `cur=points[i]`,
  вычисляем `ang = atan2(dy, dx)`, и ставим `points[i] = prev + (cos(ang), sin(ang)) * L`.

Почему это даёт "инерционный" хвост: направление берётся на старое положение `cur`, поэтому сегмент
не прыгает в произвольную позу, а запаздывает относительно головы.

### Лапки: sticky-опора + шаг + 2-bone IK

- Каждая лапка хранит `foot_target` в мире и состояние шага (`from/to`, прогресс, lift-dir).
- В `Dragon.update()` для каждой лапы:
  - берём локальный базис сегмента `(tangent=t, normal=n)` через `_frame_at(idx)`;
  - считаем `hip = points[idx] + n * side * leg_hip_offset`;
  - считаем "желаемую" опору `desired` (в сторону `leg_spread` и назад `leg_back` + небольшой wave);
  - если `desired` слишком далеко от `foot_target`, начинаем шаг; иначе удерживаем опору.
- Поза (колено/стопа) находится аналитическим 2-bone IK (`solve_two_bone_ik_2d`, закон косинусов).

### Рендер: bones / skin / hybrid

- `bones`: полилиния позвоночника + "рёбра" (дуги в локальном базисе `(t, n)`).
- `skin`: "лента" тела (две кромки по нормали с тейперовкой радиуса по хвосту).
- `hybrid`: оба режима вместе.
- "микро-волна" применяется только на отрисовке и не ломает constraint длины сегментов.

## Параметры (основные поля в `Dragon.__init__`)

Менять можно почти всё, но часть параметров требуют `dragon.reset()` (потому что пересоздаются массивы/лапки).

- Требуют `reset()`: `N`, `L`, `leg_pairs` (и любые параметры, которые меняют количество/индексы лап).
- Безопасно менять на лету: `head_*`, `wave_*`, `radius_*`, `rib_*`, `leg_*`, `step_*` (если логика обновляет эти значения каждый кадр).

## Улучшения (план)

См. файлы задач:

- `task1.md` (увеличить лапы и сгладить шаги)
- `task2.md` (добавить runtime-ползунки)
- `task3.md` (пресеты/"скины" параметров)
