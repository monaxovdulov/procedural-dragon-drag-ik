# Task 4: Квадрупед (4 лапы) сверху, походка и рендер “как у дракона”

## Цель

Сохранить вид “сверху” (2D), но сделать лапы:

- Ровно 4: передняя левая/правая и задняя левая/правая (не “сороконожка”).
- С устойчивой походкой: меньше дребезга, понятный ритм, шаги не стартуют одновременно “все сразу”.
- С более читаемой анатомией в рендере: бедро/колено/стопа, суставы, простая “ступня” вместо палок.

## Файлы

- `main.py`

## Ограничения (важно)

- Вид сверху оставляем: не добавляем “землю”, высоту, гравитацию.
- Структурные параметры (`N`, `L`, `leg_pairs`) менять только вместе с `dragon.reset()`.
- В проекте уже есть sliders + presets: придерживаемся варианта A.
  При применении пресета обновляем `sliders[*].value`, чтобы `apply_sliders()` не перезатирал параметры.

## План реализации (по шагам, с промежуточной проверкой)

### Шаг 1: Ровно 4 лапы и фиксированные точки крепления

1. В `Dragon.__init__` выставить дефолт `self.leg_pairs = 2`.
2. В `Dragon.reset()` перестать равномерно размазывать лапы по телу.
   Вместо этого задать 2 точки крепления:
   - передняя пара: `attach_front = int(self.N * 0.28)`
   - задняя пара: `attach_back  = int(self.N * 0.55)`
3. В `Leg` добавить метаданные:
   - `pair_id: int` (0 = front, 1 = back)
   - `is_front: bool`
   - (опционально) `name: str` для debug (“FL/FR/BL/BR”)

Критерии: всегда 4 ноги, всегда на передней/задней части тела, reset (`R`) даёт стабильную раскладку.

### Шаг 2: Desired foothold “по движению”, а не только по нормали

Проблема сейчас: `desired` почти всегда функция от `(t, n)` и времени, но не от реального движения корпуса.
Из-за этого при резких рывках мышью нога либо дребезжит, либо ставится в странные места.

Решение (минимально-локальное, без копирования всего `points`):

1. В `Leg` добавить:
   - `prev_attach_pos: Vector2`
   - `attach_vel: Vector2`
2. В `Dragon.update()` после обновления позвоночника (после цикла `for i in range(1, self.N): ...`) обновлять для каждой ноги:
   - `leg.attach_vel = (self.points[idx] - leg.prev_attach_pos) / dt` (если `dt > 0`)
   - `leg.prev_attach_pos = Vector2(self.points[idx])`
3. При расчёте `desired` использовать `move_dir = normalize(leg.attach_vel)` (или fallback на `t`):
   - добавлять “шаг вперёд” по `move_dir` (stride) и “опору назад” по `-t` (stance)
4. Разнести слегка перед/зад:
   - передние чуть больше тянутся “вперёд”, задние чуть больше “назад”.

Стартовые параметры (как новые поля `Dragon`, дальше можно вынести в sliders):

```python
self.stride_front = 22.0
self.stride_back = 16.0
self.move_vel_eps = 40.0   # ниже этого считаем, что стоим (stride почти 0)
```

Правило: когда стоим (скорость мала), `stride` должен плавно уходить к 0.

Критерии: при спокойном движении мыши ноги “шагают по направлению”, при остановке не пытаются “догонять” phantom-target.

### Шаг 3: Контроллер походки (гейт), чтобы убрать синхронный дребезг

Заменяем простое правило “если далеко -> шагай” на “далеко + тайминги + партнёр”.

1. В `Leg` добавить:
   - `time_since_step: float` (копится в stance, сбрасывается при `begin_step`)
2. В `Dragon.__init__` добавить параметры:

```python
self.min_stance_time = 0.20  # минимально стоять, прежде чем снова шагать
self.max_step_per_pair = 1   # не больше одной ноги в паре одновременно в swing
```

3. В `Dragon.update()` перед `leg.begin_step(...)` проверять:
   - `leg.time_since_step >= self.min_stance_time`
   - партнёрная нога этой же пары (opposite `side`) сейчас не `stepping`

Поиск партнёра: сделать маленькую helper-функцию, которая по `(pair_id, side)` возвращает нужный `Leg`.

Критерии: исчезает “оба одновременно”, уменьшается jitter, походка читается даже при резком drag.

### Шаг 4: Перед/зад в IK и фазах (анатомия и ритм)

1. Развести `bend_dir` для перед/зад (чтобы “локоть/колено” выглядели согласованно).
   Простое правило:
   - front: сгиб чуть “вперёд по движению”
   - back: сгиб чуть “назад по движению”
2. Ввести небольшой фазовый сдвиг шага между перед/зад (чтобы не было зеркальной синхронности).

Критерии: колено/локоть перестаёт “переламываться” в случайную сторону, исчезает ощущение “две одинаковые пары”.

### Шаг 5: Рендер лап (капсулы + суставы + стопа)

Текущий рендер = 2 линии + когти; это даёт ощущение палок.

Минимальный апгрейд без 3D:

1. Рисовать суставы кружками (`hip`, `knee`, `foot`) с небольшими радиусами.
2. Рисовать кости толще и с лёгкой разницей толщин (верхняя кость толще нижней).
3. Добавить “ступню” как маленький клин/ромб:
   - ориентировать по направлению `foot - knee`
   - когти привязать к этому базису.

Критерии: даже когда дракон стоит, лапа читается как “суставы + стопа”, а не как палка.

### Шаг 6: UI / Presets (подкрутка без перезапуска)

1. Добавить 3–6 слайдеров под походку:
   - `stride_front`, `stride_back`, `min_stance_time`, (опц.) `move_vel_eps`
2. Добавить soft preset `quadruped_real` и повесить на свободную клавишу.

Примечание: сейчас заняты `F1..F7`. Варианты:
- Вариант 1: заменить один пресет (например `cartoon`) на `quadruped_real`.
- Вариант 2: добавить `F8` (потребует только один новый `elif`).

## Критерии готовности (Definition of Done)

- Всегда ровно 4 лапы (две пары: перед/зад).
- При движении мыши шаги “в направлении движения” и без дребезга.
- В stance (когда мышь почти не двигается) `foot_target` стабилен и не гуляет.
- `TAB` UI работает, пресеты не “откатываются” в следующий кадр из-за `apply_sliders()`.

## Ручная проверка

1. `uv run main.py`
2. `TAB` показать/скрыть UI, потянуть слайдеры походки.
3. В `mode="hybrid"` поводить мышью, затем остановить и посмотреть, что ноги не дёргаются.
4. `D` debug: проверить `foot_target` и частоту шагов.
5. Пресеты: переключить и убедиться, что слайдеры синхронизируются (вариант A).
